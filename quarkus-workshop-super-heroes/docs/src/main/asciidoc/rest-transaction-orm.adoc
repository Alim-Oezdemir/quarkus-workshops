[[rest-transaction-orm]]
= Transactions and ORM

The Hero API's role is to allow CRUD operations on Super Heroes.
In this module we will create a Hero entity and persist/update/delete/retreive it from a Postgres database in a transactional way.

== Architecture Diagram

[[rest-transaction-orm-architecture-diagram]]
.Architecture Diagram
image::rest-transaction-orm-architecture-diagram.png[]

== Directory Structure

In this module we will add extra classes to the Hero API project.
You will end-up with the following directory structure:

[source,text]
----
.
└── hero-api
   ├── pom.xml
   └── src
       └── main
           └── java
               └── io
                   └── quarkus
                       └── workshop
                           └── superheroes
                               └── hero
                                   ├── Hero.java
                                   ├── HeroResource.java
                                   └── HeroService.java
----

== Hero Entity

Hibernate ORM is the de facto JPA implementation and offers you the full breadth of an Object Relational Mapper.
It makes complex mappings possible, but it does not make simple and common mappings trivial.
Hibernate ORM with Panache focuses on making your entities trivial and fun to write in Quarkus.footnote:[Panache https://github.com/quarkusio/quarkus/tree/master/extensions/panache]

Because JPA and Bean Validation work well together, we will use Bean Validation to constrain our business model.
So first, make sure to add the Panache JPA and Bean Validation extensions to your `pom.xml`:

[source,xml,indent=0]
----
include::{github-raw}/api-hero/pom.xml[tags=adocDependencyHibernate]
include::{github-raw}/api-hero/pom.xml[tags=adocDependencyValidator]
----

To define a Panache entity, simply extend `PanacheEntity`, annotate it with `@Entity` and add your columns as public fields (no need to have getters and setters).
The `Hero` entity should look like this:

[source]
----
include::{github-raw}/api-hero/src/main/java/io/quarkus/workshop/superheroes/hero/Hero.java[tags=adocEntity;!adocFindRandom]
----

Notice that you can put all your JPA column annotations and Bean Validation constraint annotations on the public fields.

=== Adding Operations

Thanks to Panache, once you have written the `Hero` entity, here are the most common operations you will be able to do:

[source]
----
// creating a hero
Hero hero = new Hero();
hero.name = "Superman";
hero.level = 9;

// persist it
hero.persist();

// getting a list of all Hero entities
List<Hero> heroes = Hero.listAll();

// finding a specific hero by ID
hero = Hero.findById(id);

// counting all heroes
long countAll = Hero.count();
----

But we are missing a business method:
we need to return a random hero.
For that it's just a matter to add the following method to our `Hero.java` entity:

[source]
----
include::{github-raw}/api-hero/src/main/java/io/quarkus/workshop/superheroes/hero/Hero.java[tags=adocFindRandom]
----

== HeroService Transactional Service

To manipulate the `Hero` entity we will develop a transaction `HeroService` class.
The idea is to wrap methods modifying your database (e.g. `entity.persist()`) within a transaction.
Marking a CDI bean method `@Transactional` will do that for you and make that method a transaction boundary.

`@Transactional` can be used to control transaction boundaries on any CDI bean at the method level or at the class level to ensure every method is transactional.
You can control whether and how the transaction is started with parameters on `@Transactional`:

* `@Transactional(REQUIRED)` (default): starts a transaction if none was started, stays with the existing one otherwise.
* `@Transactional(REQUIRES_NEW)`: starts a transaction if none was started ; if an existing one was started, suspends it and starts a new one for the boundary of that method.
* `@Transactional(MANDATORY)`: fails if no transaction was started ; works within the existing transaction otherwise.
* `@Transactional(SUPPORTS)`: if a transaction was started, joins it ; otherwise works with no transaction.
* `@Transactional(NOT_SUPPORTED)`: if a transaction was started, suspends it and works with no transaction for the boundary of the method ; otherwise works with no transaction.
* `@Transactional(NEVER)`: if a transaction was started, raises an exception ; otherwise works with no transaction.

[source]
----
include::{github-raw}/api-hero/src/main/java/io/quarkus/workshop/superheroes/hero/HeroService.java[tags=adocTransactional;!adocConfigProperty;!adocPersistHeroLevel]
----

== Configuring the Datasource

Our project now requires a connection to a PostgreSQL database.
The main way of obtaining connections to a database is to use a datasource.
In Quarkus, the out of the box datasource and connection pooling implementation is Agroal.footnote:[Agroal https://agroal.github.io]

To install the PostgreSQL driver dependency, just run the following command:

[source,shell]
----
$ ./mvnw quarkus:add-extension -Dextensions="jdbc-postgresql"
----

This will add the following dependency in the `pom.xml` file:

[source,xml,indent=0]
----
include::{github-raw}/api-hero/pom.xml[tags=adocDependencyPostgresql]
----

Once the dependencies are added to your `pom.xml` file, you’ll need to configure Agroal.
This is done in the `src/main/resources/application.properties` file.
Just add the following datasource configuration:

[source,text]
----
include::{github-raw}/api-hero/src/main/resources/application.properties[tags=adocDatasource]
----

== HeroResource Endpoint

The `HeroResource` Endpoint was bootstrapped with only one method `hello()`.
We need to add extra methods that will allow CRUD operations on heroes.
Here are the new methods to add to the `HeroResource` class:

[source]
----
include::{github-raw}/api-hero/src/main/java/io/quarkus/workshop/superheroes/hero/HeroResource.java[tags=adocResource;!adocOpenAPI;!adocMetrics]
----

== Dependency Injection

Dependency injection in Quarkus is based on ArC which is a CDI-based dependency injection solution tailored for Quarkus' architecture.footnote:[ArC https://github.com/quarkusio/quarkus/tree/master/independent-projects/arc]
You can learn more about it in the Contexts and Dependency Injection guide.footnote:[Quarkus - Contexts and Dependency Injection https://quarkus.io/guides/cdi-reference.html]

ArC comes as a dependency of `quarkus-resteasy` so you already have it handy.
That's why you were able to use `@Inject` in the `HeroResource` to inject a reference to `HeroService`.
