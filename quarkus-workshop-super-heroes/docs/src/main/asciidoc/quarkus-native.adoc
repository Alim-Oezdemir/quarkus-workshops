[[quarkus-native]]
= Building Native Images

== Building a Native Executable

Let's now produce a native executable for our application.
As explained in the introduction of this chapter, Quarkus is able to generate native executables.
Just like Go, native executable don't need a VM to run,t hey contain the whole application, like an `.exe` file on Windows.

It improves the startup time of the application, and produces a minimal disk footprint.
The executable would have everything to run the application including the "JVM" (shrunk to be just enough to run the application), and the application.

[NOTE]
--
Choosing JVM execution vs native executable execution depends on your application needs and environment.
Discuss with the lab organizers for some insights
--

To do so, you will find in the `pom.xml` the following profile:

[source,xml]
----
<profile>
  <id>native</id>
  <activation>
    <property>
      <name>native</name>
    </property>
  </activation>
  <build>
    <plugins>
      <plugin>
        <groupId>io.quarkus</groupId>
        <artifactId>quarkus-maven-plugin</artifactId>
        <version>${quarkus.version}</version>
        <executions>
          <execution>
            <goals>
              <goal>native-image</goal>
            </goals>
            <configuration>
              <enableHttpUrlHandler>true</enableHttpUrlHandler>
            </configuration>
          </execution>
        </executions>
      </plugin>
      <plugin>
        <artifactId>maven-failsafe-plugin</artifactId>
        <version>${surefire-plugin.version}</version>
        <executions>
          <execution>
            <goals>
              <goal>integration-test</goal>
              <goal>verify</goal>
            </goals>
            <configuration>
              <systemProperties>
                <native.image.path>${project.build.directory}/${project.build.finalName}-runner</native.image.path>
              </systemProperties>
            </configuration>
          </execution>
        </executions>
      </plugin>
    </plugins>
  </build>
</profile>
----

Create a native executable using: `./mvnw package -Pnative`.
In addition to the regular files (`rest-hero-1.0-SNAPSHOT.jar` and `rest-hero-1.0-SNAPSHOT-runner.jar`), the build also produces `target/rest-hero-1.0-SNAPSHOT-runner` (notice that there is no `.jar` file extension).
You can run it using: `./target/rest-hero-1.0-SNAPSHOT-runner`.


[WARNING]
====
Creating a native executable requires a lot of memory and CPU.
It also takes a few minutes, even for simple application like the Hero microservice.
Most of the time is spent during the dead code elimination, as it traverse the whole (closed) world.
====

== Testing the Native Executable

Producing a native executable can lead to a few issues, and so it's also a good idea to run some tests against the application running in the native file.
In the `pom.xml` file, the native profile contains:

[source,xml,indent=0]
----
<plugin>
  <artifactId>maven-failsafe-plugin</artifactId>
  <version>${surefire-plugin.version}</version>
  <executions>
    <execution>
      <goals>
        <goal>integration-test</goal>
        <goal>verify</goal>
      </goals>
      <configuration>
        <systemProperties>
          <native.image.path>${project.build.directory}/${project.build.finalName}-runner</native.image.path>
        </systemProperties>
      </configuration>
    </execution>
  </executions>
</plugin>
----

This instructs the failsafe-maven-plugin to run integration-test and indicates the location of the produced native executable.

Then, open the `src/test/java/io/quarkus/workshop/superheroes/hero/NativeHeroResourceIT.java` and update it with the following:

[source,java]
----
include::{github-raw}/super-heroes/rest-hero/src/test/java/io/quarkus/workshop/superheroes/hero/NativeHeroResourceIT.java[tags=adocResourceIT]
----

Instead of using `@QuarkusTest`, it uses the `@SubstrateTest` test runner that starts the application from the native file before the tests.
The executable is retrieved using the `native.image.path` system property configured in the Failsafe Maven Plugin.
We extend our previous tests, but you can also implement your own tests.

[NOTE]
--
Notice that `NativeHeroResourceIT` does not extend `HeroResourceTest`.
It is a good practice to share the same tests for native and JVM mode that way but in our case the behavior is a bit different.
For example, we do not want Swagger UI exposed in our native image.
--

Before running the test, we need to configure in which _profile_ they run.
If you look at the test class, it starts a database on a specific port (5499).
We need to configure the application to connect on this port.
For this edit the `application.properties` and add:

[source]
----
quarkus.test.native-image-profile=it
%it.quarkus.datasource.url=jdbc:postgresql://localhost:5499/heroes_database
----

The first line configure the profile to use in the native integration tests.
Here we use a custom profile named `it`.
Note that by default `prod` is used.
The second line overrides the JDBC url to use the right port.
Now we can run the tests.

To see the `NativeHeroResourceIT` run against the native executable, use `./mvnw verify -Pnative`:

[source]
----
[rest-hero-1.0-SNAPSHOT-runner:43534]    (compile):   8,088.33 ms
[rest-hero-1.0-SNAPSHOT-runner:43534]      compile:  12,693.01 ms
[rest-hero-1.0-SNAPSHOT-runner:43534]        image:   1,980.24 ms
[rest-hero-1.0-SNAPSHOT-runner:43534]        write:     592.88 ms
[rest-hero-1.0-SNAPSHOT-runner:43534]      [total]:  42,691.42 ms
[INFO]
[INFO] -------------------------------------------------------
[INFO]  T E S T S
[INFO] -------------------------------------------------------
[INFO] Running io.quarkus.workshop.superheroes.hero.NativeHeroResourceIT
Executing [/Users/agoncal/Code/rest-hero/target/rest-hero-1.0-SNAPSHOT-runner, -Dquarkus.http.port=8081, -Dtest.url=http://localhost:8081, -Dquarkus.log.file.path=target/quarkus.log]
2019-10-04 15:55:59,044 INFO  [io.quarkus] (main) Quarkus 0.25.0 started in 0.012s. Listening on: http://0.0.0.0:8081
2019-10-04 15:55:59,044 INFO  [io.quarkus] (main) Profile prod activated.
2019-10-04 15:55:59,044 INFO  [io.quarkus] (main) Installed features: [cdi, resteasy]
[INFO]
[INFO] Results:
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
----
