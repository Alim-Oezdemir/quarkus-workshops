[[quarkus-native]]
= Building Native Images

== Building a Native Executable

Let's now produce a native executable for our application.
As explained in the introduction of this chapter, Quarkus is able to generate native executables.
Just like Go, native executable don't need a VM to run,t hey contain the whole application, like an `.exe` file on Windows.

It improves the startup time of the application, and produces a minimal disk footprint.
The executable would have everything to run the application including the "JVM" (shrunk to be just enough to run the application), and the application.

[NOTE]
--
Choosing JVM execution vs native executable execution depends on your application needs and environment.
Discuss with the lab organizers for some insights
--

To do so, you will find in the `pom.xml` the following profile:

[source,xml]
----
<profile>
  <id>native</id>
  <activation>
    <property>
      <name>native</name>
    </property>
  </activation>
  <build>
    <plugins>
      <plugin>
        <groupId>io.quarkus</groupId>
        <artifactId>quarkus-maven-plugin</artifactId>
        <version>${quarkus.version}</version>
        <executions>
          <execution>
            <goals>
              <goal>native-image</goal>
            </goals>
            <configuration>
              <enableHttpUrlHandler>true</enableHttpUrlHandler>
            </configuration>
          </execution>
        </executions>
      </plugin>
      <plugin>
        <artifactId>maven-failsafe-plugin</artifactId>
        <version>${surefire-plugin.version}</version>
        <executions>
          <execution>
            <goals>
              <goal>integration-test</goal>
              <goal>verify</goal>
            </goals>
            <configuration>
              <systemProperties>
                <native.image.path>${project.build.directory}/${project.build.finalName}-runner</native.image.path>
              </systemProperties>
            </configuration>
          </execution>
        </executions>
      </plugin>
    </plugins>
  </build>
</profile>
----

Create a native executable using: `./mvnw package -Pnative`.
In addition to the regular files (`rest-hero-1.0-SNAPSHOT.jar` and `rest-hero-1.0-SNAPSHOT-runner.jar`), the build also produces `target/rest-hero-1.0-SNAPSHOT-runner` (notice that there is no `.jar` file extension).
You can run it using: `./target/rest-hero-1.0-SNAPSHOT-runner`.

== Testing the Native Executable

Producing a native executable can lead to a few issues, and so it's also a good idea to run some tests against the application running in the native file.
In the `pom.xml` file, the native profile contains:

[source,xml,indent=0]
----
<plugin>
  <artifactId>maven-failsafe-plugin</artifactId>
  <version>${surefire-plugin.version}</version>
  <executions>
    <execution>
      <goals>
        <goal>integration-test</goal>
        <goal>verify</goal>
      </goals>
      <configuration>
        <systemProperties>
          <native.image.path>${project.build.directory}/${project.build.finalName}-runner</native.image.path>
        </systemProperties>
      </configuration>
    </execution>
  </executions>
</plugin>
----

This instructs the failsafe-maven-plugin to run integration-test and indicates the location of the produced native executable.

Then, open the src/test/java/io/quarkus/workshop/superheroes/hero/NativeHeroResourceIT.java` and update it with the following:
It contains:

[source,java]
----
include::{github-raw}/super-heroes/rest-hero/src/test/java/io/quarkus/workshop/superheroes/hero/NativeHeroResourceIT.java[tags=adocResourceIT]
----

Instead of using `@QuarkusTest`, it uses the `@SubstrateTest` test runner that starts the application from the native file before the tests.
The executable is retrieved using the `native.image.path` system property configured in the Failsafe Maven Plugin.
We extend our previous tests, but you can also implement your own tests.

[NOTE]
--
Notice that `NativeHeroResourceIT` does not extend `HeroResourceTest`.
It is a good practice to share the same tests for native and JVM mode that way but in our case the behavior is a bit different.
For example, we don not want Swager UI exposed in our native image.
--

To see the `NativeHeroResourceIT` run against the native executable, use `./mvnw verify -Pnative`:

[source]
----
[rest-hero-1.0-SNAPSHOT-runner:43534]    (compile):   8,088.33 ms
[rest-hero-1.0-SNAPSHOT-runner:43534]      compile:  12,693.01 ms
[rest-hero-1.0-SNAPSHOT-runner:43534]        image:   1,980.24 ms
[rest-hero-1.0-SNAPSHOT-runner:43534]        write:     592.88 ms
[rest-hero-1.0-SNAPSHOT-runner:43534]      [total]:  42,691.42 ms
[INFO]
[INFO] -------------------------------------------------------
[INFO]  T E S T S
[INFO] -------------------------------------------------------
[INFO] Running io.quarkus.workshop.superheroes.hero.NativeHeroResourceIT
Executing [/Users/agoncal/Code/rest-hero/target/rest-hero-1.0-SNAPSHOT-runner, -Dquarkus.http.port=8081, -Dtest.url=http://localhost:8081, -Dquarkus.log.file.path=target/quarkus.log]
2019-10-04 15:55:59,044 INFO  [io.quarkus] (main) Quarkus 0.25.0 started in 0.012s. Listening on: http://0.0.0.0:8081
2019-10-04 15:55:59,044 INFO  [io.quarkus] (main) Profile prod activated.
2019-10-04 15:55:59,044 INFO  [io.quarkus] (main) Installed features: [cdi, resteasy]
[INFO]
[INFO] Results:
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
----

== Displaying the Current Profile

Quarkus supports the notion of configuration profiles.
These allow you to have multiple configuration in the same file and select between them via a profile name.

By default Quarkus has three profiles, although it is possible to use as many as you like. The default profiles are:

* `dev` - Activated when in development mode (i.e. `quarkus:dev`)
* `test` - Activated when running tests
* `prod` - The default profile when not running in development or test mode

Let's change the `HeroApplicationLifeCycle` so it displays the current profile.
For that, just add a log invoking the `ProfileManager.getActiveProfile()` method:

[source,indent=0]
----
include::{github-raw}/super-heroes/rest-hero/src/main/java/io/quarkus/workshop/superheroes/hero/HeroApplicationLifeCycle.java[tags=adocStartupEvent]
----
