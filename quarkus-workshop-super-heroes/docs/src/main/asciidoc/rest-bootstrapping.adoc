[[rest-bootstrapping]]
= Bootstrapping the Project

== Architecture Diagram

[[rest-boostrapping-architecture-diagram]]
.Architecture Diagram
image::rest-boostrapping-architecture-diagram.png[]

== Bootstrapping the Hero REST Endpoint

The easiest way to create a new Quarkus project is to use Maven archetype.
Let's say you have a `quarkus-workshop` root directory where you have all your code, create a `api-hero` sub-directory, open a terminal and run the following command:

[source,shell]
----
include::{github-raw}/api-hero/bootstrap.sh[tag=adocSnippet]
----

== Directory Structure

Once you bootstrap the project, you get the following directory structure with a few Java classes and other artifacts :

[source,text]
----
.
└── hero-api
   ├── mvnw
   ├── mvnw.cmd
   ├── pom.xml
   └── src
       ├── main
       │   ├── docker
       │   │   ├── Dockerfile.jvm
       │   │   └── Dockerfile.native
       │   ├── java
       │   │   └── io
       │   │       └── quarkus
       │   │           └── workshop
       │   │               └── superheroes
       │   │                   └── hero
       │   │                       └── HeroResource.java
       │   └── resources
       │       ├── META-INF
       │       │   └── resources
       │       │       └── index.html
       │       └── application.properties
       └── test
           └── java
               └── io
                   └── quarkus
                       └── workshop
                           └── superheroes
                               └── hero
                                   ├── HeroResourceTest.java
                                   └── NativeHeroResourceIT.java
----

The Maven archetype generates the following `api-hero` sub-directory:

* the Maven structure with a `pom.xml`
* an `io.quarkus.workshop.superheroes.hero.HeroResource` resource exposed on `/api/heroes`
* an associated unit test
* the landing page `index.html` that is accessible on http://localhost:8080 after starting the application
* example Dockerfile files for both native and jvm modes in `src/main/docker`
* the `application.properties` configuration file

Once generated, look at the `pom.xml`.
You will find the import of the Quarkus BOM, allowing you to omit the version on the different Quarkus dependencies.
In addition, you can see the `quarkus-maven-plugin` responsible of the packaging of the application and also providing the development mode.

[source,xml,indent=0]
----
include::{github-raw}/pom.xml[tags=adocProperties;!adocPropertiesTestcontainers;!adocPropertiesOthers]
include::{github-raw}/pom.xml[tags=adocDependencyManagement;!adocDependencyTestBom]
include::{github-raw}/pom.xml[tags=adocBuild;!adocBuildOthers]
----

If we focus on the dependencies section, you can see the extension allowing the development of REST applications:

[source,xml,indent=0]
----
include::{github-raw}/api-hero/pom.xml[tags=adocDependencyResteasy]
----

== The JAX-RS resource

During the project creation, the `src/main/java/io/quarkus/workshop/superheroes/hero/HeroResource.java` file has been created with the following content:

[source]
----
@Path("/api/heroes")
public class HeroResource {

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return "hello";
    }
}
----

It's a very simple REST endpoint, returning "hello" to requests on "/hello".

== Running the application

Now we are ready to run our application.
Use: `./mvnw compile quarkus:dev`:

[source,shell]
----
$ ./mvnw compile quarkus:dev
[INFO] -------------< io.quarkus.workshop.super-heroes:hero-api >--------------
[INFO] Building hero-api 1.0-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
[INFO]
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ hero-api ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] Copying 2 resources
[INFO]
[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ hero-api ---
[INFO] Changes detected - recompiling the module!
[INFO] Compiling 1 source file to /Users/agoncal/Code/Quarkus/hero-api/target/classes
[INFO]
[INFO] --- quarkus-maven-plugin:0.23.1:dev (default-cli) @ hero-api ---
[ERROR] Port 5005 in use, not starting in debug mode
2019-10-04 10:08:11,536 INFO  [io.qua.dep.QuarkusAugmentor] (main) Beginning quarkus augmentation
2019-10-04 10:08:11,989 INFO  [io.qua.dep.QuarkusAugmentor] (main) Quarkus augmentation completed in 453ms
2019-10-04 10:08:12,294 INFO  [io.quarkus] (main) Quarkus 0.23.1 started in 0.891s. Listening on: http://0.0.0.0:8080
2019-10-04 10:08:12,295 INFO  [io.quarkus] (main) Profile dev activated. Live Coding activated.
2019-10-04 10:08:12,295 INFO  [io.quarkus] (main) Installed features: [cdi, resteasy]
----

Then check that the endpoint returns `hello` as expected:

[source,shell]
----
$ curl http://localhost:8080/api/heroes
hello
----

== Development Mode

`quarkus:dev` runs Quarkus in development mode.
This enables hot deployment with background compilation, which means that when you modify your Java files and/or your resource files and invoke a REST endpoint (i.e. cUrl command or refresh your browser), these changes will automatically take effect.
This works too for resource files like the configuration property file.
Refreshing the browser triggers a scan of the workspace, and if any changes are detected, the Java files are recompiled and the application is redeployed;
your request is then serviced by the redeployed application.
If there are any issues with compilation or deployment an error page will let you know.

This will also listen for a debugger on port 5005.
If you want to wait for the debugger to attach before running you can pass `-Ddebug` on the command line.
If you don't want the debugger at all you can use `-Ddebug=false`.

To check that the hot reload is working, update the method `HeroResource.hello()` by returning the String "hello hero".
Now, execute the cUrl command again, the output has changed without you to having to stop and restart Quarkus:

[source,shell]
----
$ curl http://localhost:8080/api/heroes
hello hero
----

== Testing

All right, so far so good, but wouldn’t it be better with a few tests, just in case.

In the generated `pom.xml` file, you can see 2 test dependencies:

[source,xml,indent=0]
----
include::{github-raw}/api-hero/pom.xml[tags=adocDependencyTest]
----

Quarkus supports Junit 4 and Junit 5 tests.
In the generated project, we use Junit 5.
Because of this, the version of the Surefire Maven Plugin must be set, as the default version does not support Junit 5:

[source,xml,indent=0]
----
include::{github-raw}/pom.xml[tags=adocProperties;!adocPropertiesTestcontainers;!adocPropertiesOthers]
include::{github-raw}/pom.xml[tags=adocBuildSurefire]
----

We also set the `java.util.logging` system property to make sure tests will use the correct logmanager.

The generated project contains a simple test in `src/test/java/io/quarkus/workshop/superheroes/hero/HeroResourceTest.java`.

[source]
----
@QuarkusTest
public class HeroResourceTest {

    @Test
    public void testHelloEndpoint() {
        given()
          .when().get("/api/heroes")
          .then()
             .statusCode(200)
             .body(is("hello"));
    }
}
----

By using the `QuarkusTest` runner, the `HeroResourceTest` class instructs JUnit to start the application before the tests.
Then, the `testHelloEndpoint` method checks the HTTP response status code and content.
Notice that these tests use RestAssured, but feel free to use your favorite library.footnote:[RestAssured http://rest-assured.io]

Execute it with `./mvnw test` or from your IDE.

== Packaging and run the application

The application is packaged using `./mvnw package`.
It produces 2 jar files in `/target`:

* `hero-api-1.0-SNAPSHOT.jar` : containing just the classes and resources of the projects, it’s the regular artifact produced by the Maven build;
* `hero-api-1.0-SNAPSHOT-runner.jar` : being an executable jar. Be aware that it’s not an über-jar as the dependencies are copied into the `target/lib` directory.

You can run the application using: `java -jar hero-api-1.0-SNAPSHOT-runner.jar`.

[NOTE]
====
Before running the application, don’t forget to stop the hot reload mode (hit CTRL+C), or you will have a port conflict.
====

== Building a Native Executable

Let’s now produce a native executable for our application.
It improves the startup time of the application, and produces a minimal disk footprint.
The executable would have everything to run the application including the "JVM" (shrunk to be just enough to run the application), and the application.

To do so, you will find in the `pom.xml` the following profile:

[source,xml]
----
<profile>
  <id>native</id>
  <activation>
    <property>
      <name>native</name>
    </property>
  </activation>
  <build>
    <plugins>
      <plugin>
        <groupId>io.quarkus</groupId>
        <artifactId>quarkus-maven-plugin</artifactId>
        <version>${quarkus.version}</version>
        <executions>
          <execution>
            <goals>
              <goal>native-image</goal>
            </goals>
            <configuration>
              <enableHttpUrlHandler>true</enableHttpUrlHandler>
            </configuration>
          </execution>
        </executions>
      </plugin>
      <plugin>
        <artifactId>maven-failsafe-plugin</artifactId>
        <version>${surefire-plugin.version}</version>
        <executions>
          <execution>
            <goals>
              <goal>integration-test</goal>
              <goal>verify</goal>
            </goals>
            <configuration>
              <systemProperties>
                <native.image.path>${project.build.directory}/${project.build.finalName}-runner</native.image.path>
              </systemProperties>
            </configuration>
          </execution>
        </executions>
      </plugin>
    </plugins>
  </build>
</profile>
----

Create a native executable using: `./mvnw package -Pnative`.
In addition to the regular files, the build also produces `target/hero-api-1.0-SNAPSHOT-runner` (notice that there is no `.jar` file extension).
You can run it using: `./target/hero-api-1.0-SNAPSHOT-runner`.

== Testing the Native Executable

Producing a native executable can lead to a few issues, and so it’s also a good idea to run some tests against the application running in the native file.
In the `pom.xml` file, the native profile contains:

[source,xml,indent=0]
----
<plugin>
  <artifactId>maven-failsafe-plugin</artifactId>
  <version>${surefire-plugin.version}</version>
  <executions>
    <execution>
      <goals>
        <goal>integration-test</goal>
        <goal>verify</goal>
      </goals>
      <configuration>
        <systemProperties>
          <native.image.path>${project.build.directory}/${project.build.finalName}-runner</native.image.path>
        </systemProperties>
      </configuration>
    </execution>
  </executions>
</plugin>
----

This instructs the failsafe-maven-plugin to run integration-test and indicates the location of the produced native executable.

Then, open the src/test/java/io/quarkus/workshop/superheroes/hero/NativeHeroResourceIT.java`.
It contains:

[source]
----
@SubstrateTest
public class NativeHeroResourceIT extends HeroResourceTest {

    // Execute the same tests but in native mode.
}
----

Notice that `NativeHeroResourceIT` extends from `HeroResourceTest`.
Instead of using `@QuarkusTest`, it uses the `@SubstrateTest` test runner that starts the application from the native file before the tests.
The executable is retrieved using the `native.image.path` system property configured in the Failsafe Maven Plugin.
We extend our previous tests, but you can also implement your own tests.

To see the `NativeHeroResourceIT` run against the native executable, use `./mvnw verify -Pnative`:

[source]
----
[hero-api-1.0-SNAPSHOT-runner:43534]    (compile):   8,088.33 ms
[hero-api-1.0-SNAPSHOT-runner:43534]      compile:  12,693.01 ms
[hero-api-1.0-SNAPSHOT-runner:43534]        image:   1,980.24 ms
[hero-api-1.0-SNAPSHOT-runner:43534]        write:     592.88 ms
[hero-api-1.0-SNAPSHOT-runner:43534]      [total]:  42,691.42 ms
[INFO]
[INFO] -------------------------------------------------------
[INFO]  T E S T S
[INFO] -------------------------------------------------------
[INFO] Running io.quarkus.workshop.superheroes.hero.NativeHeroResourceIT
Executing [/Users/agoncal/Code/hero-api/target/hero-api-1.0-SNAPSHOT-runner, -Dquarkus.http.port=8081, -Dtest.url=http://localhost:8081, -Dquarkus.log.file.path=target/quarkus.log]
2019-10-04 15:55:59,044 INFO  [io.quarkus] (main) Quarkus 0.23.1 started in 0.012s. Listening on: http://0.0.0.0:8081
2019-10-04 15:55:59,044 INFO  [io.quarkus] (main) Profile prod activated.
2019-10-04 15:55:59,044 INFO  [io.quarkus] (main) Installed features: [cdi, resteasy]
[INFO]
[INFO] Results:
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
----


== Troubleshooting

You might come across the following error while developing:

[source,shell]
----
WARN  [io.qu.ne.ru.NettyRecorder] (Thread-48) Localhost lookup took more than one second, you need to add a /etc/hosts entry to improve Quarkus startup time. See https://thoeni.io/post/macos-sierra-java/ for details.
----

If this is the case, it's just a matter to add the node name of your machine to the /etc/hosts. For that, first get the name of your node with the following command:

[source,shell]
----
$ uname -n
my-node.local
----

Then `sudo vi /etc/hosts` so you have the rights to edit the file and add the following entry

[source,shell]
----
127.0.0.1 localhost my-node.local
----
